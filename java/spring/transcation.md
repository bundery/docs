# 声明式事务管理

Spring 声明式事务管理是建立在 AOP 之上的，本质是对方法前后进行拦截，在目标方法开始之前创建或者加入一个失误，在执行完目标方法之后根据执行情况提交或者回滚事务。声明式事务最大的好处就是不需要通过编程的方式管理事务，这样就不需要在业务逻辑代码中掺杂事务管理的代码。事务适合放在 Service 层，因为一个 Service方法可能包括多个`xxDao`，如果事务放在 Dao 层的方法上面，则那个 Service 方法就无法进行统一的事务管理了。

使用声明式事务管理有俩种方式：

1. 在配置文件 XML 中配置
2. 使用注解`@Transactional`标注在类或者方法上（只对`public`方法有效，方法上的注解会覆盖类上相同属性的注解）。

只有来自外部的方法调用才会被 AOP 捕获，类内部的方法调用了同类中的其他方法并不会引起事务行为，即使被调用方法使用了 @Transactional 注解。

## 事务的回滚

指示 spring 事务管理回滚一个事务的推荐方法是在当前事务的上下文内抛出异常，spring 事务管理器会捕获任何未处理的异常，然后依据规则决定是否回滚抛出异常的事务。

默认配置下 spring 只有在抛出的异常为运行时 unchecked（RuntimeException 及其子类） 异常时才回滚该事务，而抛出 checked 异常则不会导致事务回滚。不过可以明确的配置在抛出哪些异常时回滚事务（包括 checked 异常），或抛出哪些异常时不回滚。

## 事务的传播行为

有些 Service 方法除了调用 Dao 层方法外，还调用了其他 Service 方法，那么在调用其他 Service 方法的时候，这个事务是如何规定的？必须保证本方法与调用的方法在同一个事务中，否则就违反了事务的一致性。事务的传播特性就是解决这个问题的，这个工作使由Spring来帮助完成。 

> 如果没有集成 Spring 框架，那么我们必须手动控制事务，如把当前的 hibernate session 传递到下一个方法，Spring 框架可以帮助我们解决这个问题，让我们只需关注业务逻辑。

### PROPAGATION_REQUIRED

支持当前事务，如果当前没有事务，就新建一个事务。（常用）

### PROPAGATION_SUPPORTS

支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。

### PROPAGATION_MANDATORY

支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。

### PROPAGATION_REQUIRES_NEW

无论当前存不存在事务，都创建新事务。

### PROPAGATION_NOT_SUPPORTED

以非事务方式执行，如果当前存在事务，就将当前事务挂起。

### PROPAGATION_NEVER

以非事务执行，如果当前存在事务，则抛出异常。

### PROPAGATION_NESTED

为嵌套事务，实际上是借助 jdbc 的`savepoint` （在事务内部创建一系列可以 ROLLBACK 的还原点） 实现的，提交是等父事务一块提交的，属于同一个事务。子事务回滚到 savepoint，父事务可选择性回滚或者不回滚；父事务回滚子事务一定回滚。